using System;
using System.IO;
using System.Linq;
using System.Reflection;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc.ApiExplorer;
using Microsoft.AspNetCore.Mvc.Formatters;
using Microsoft.AspNetCore.Mvc.Versioning;
using Microsoft.AspNetCore.Server.Kestrel.Core;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Net.Http.Headers;
using Microsoft.OpenApi.Models;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Sentry;
using Shoko.Plugin.Abstractions.DataModels;
using Shoko.Server.API.ActionFilters;
using Shoko.Server.API.Authentication;
using Shoko.Server.API.SignalR;
using Shoko.Server.API.SignalR.Aggregate;
using Shoko.Server.API.Swagger;
using Shoko.Server.API.v3.Helpers;
using Shoko.Server.API.FileProviders;
using Shoko.Server.Extensions;
using Shoko.Server.Plugin;
using Shoko.Server.Server;
using Shoko.Server.Services;
using Shoko.Server.Utilities;
using Swashbuckle.AspNetCore.SwaggerGen;
using File = System.IO.File;
using AniDBEmitter = Shoko.Server.API.SignalR.Aggregate.AniDBEmitter;
using ShokoEventEmitter = Shoko.Server.API.SignalR.Aggregate.ShokoEventEmitter;
using QueueEmitter = Shoko.Server.API.SignalR.Aggregate.QueueEmitter;
using AVDumpEmitter = Shoko.Server.API.SignalR.Aggregate.AVDumpEmitter;
using NetworkEmitter = Shoko.Server.API.SignalR.Aggregate.NetworkEmitter;

namespace Shoko.Server.API;

public static class APIExtensions
{
    public static IServiceCollection AddAPI(this IServiceCollection services)
    {
        services.AddSingleton<LoggingEmitter>();
        services.AddSingleton<AniDBEmitter>();
        services.AddSingleton<ShokoEventEmitter>();
        services.AddSingleton<AVDumpEmitter>();
        services.AddSingleton<NetworkEmitter>();
        services.AddSingleton<QueueEmitter>();
        services.AddScoped<GeneratedPlaylistService>();
        services.AddScoped<FilterFactory>();
        services.AddScoped<WebUIFactory>();

        services.AddAuthentication(options =>
        {
            options.DefaultAuthenticateScheme = CustomAuthOptions.DefaultScheme;
            options.DefaultChallengeScheme = CustomAuthOptions.DefaultScheme;
        }).AddScheme<CustomAuthOptions, CustomAuthHandler>(CustomAuthOptions.DefaultScheme, _ => { });

        services.AddAuthorization(auth =>
        {
            auth.AddPolicy("admin",
                policy => policy.Requirements.Add(new UserHandler(user => user.IsAdmin == 1)));
            auth.AddPolicy("init",
                policy => policy.Requirements.Add(new UserHandler(user =>
                    user.JMMUserID == 0 && user.Username == "init")));
        });

        services.AddSwaggerGen(
            options =>
            {
                // resolve the IApiVersionDescriptionProvider service
                // note: that we have to build a temporary service provider here because one has not been created yet
                var provider = services.BuildServiceProvider().GetRequiredService<IApiVersionDescriptionProvider>();

                // add a swagger document for each discovered API version
                // note: you might choose to skip or document deprecated API versions differently
                foreach (var description in provider.ApiVersionDescriptions.OrderByDescending(a => a.ApiVersion))
                {
                    options.SwaggerDoc(description.GroupName, CreateInfoForApiVersion(description));
                }

                options.AddSecurityDefinition("ApiKey",
                    new OpenApiSecurityScheme()
                    {
                        Description = "Shoko API Key Header",
                        Name = "apikey",
                        In = ParameterLocation.Header,
                        Type = SecuritySchemeType.ApiKey,
                        Scheme = "apikey"
                    });

                options.AddSecurityRequirement(new OpenApiSecurityRequirement()
                {
                    {
                        new OpenApiSecurityScheme
                        {
                            Reference = new OpenApiReference
                            {
                                Type = ReferenceType.SecurityScheme, Id = "ApiKey"
                            }
                        },
                        Array.Empty<string>()
                    }
                });

                // add a custom operation filter which sets default values
                //options.OperationFilter<SwaggerDefaultValues>();

                // integrate xml comments
                //Locate the XML file being generated by ASP.NET...
                var xmlFile = "Shoko.Server.xml";
                var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
                if (File.Exists(xmlPath))
                {
                    options.IncludeXmlComments(xmlPath);
                }

                options.AddPlugins();

                var v3Enums = typeof(APIExtensions).Assembly.GetTypes()
                    .Concat(typeof(TitleLanguage).Assembly.GetTypes())
                    .Where(a => a.IsEnum)
                    .Where(a =>
                        (a.FullName?.StartsWith("Shoko.Server.API.v3.", StringComparison.InvariantCultureIgnoreCase) ?? false) ||
                        (a.FullName?.StartsWith("Shoko.Plugin.Abstractions.", StringComparison.InvariantCultureIgnoreCase) ?? false) ||
                        (a.FullName?.StartsWith("Shoko.Server.Providers.", StringComparison.InvariantCultureIgnoreCase) ?? false)
                    )
                    .Concat([
                        typeof(DayOfWeek),
                        typeof(DriveType),
                        typeof(ReleaseChannel),
                        typeof(CreatorRoleType),
                        typeof(Shoko.Models.Enums.AnimeSeason),
                        typeof(Shoko.Models.Enums.DataSourceType),
                    ])
                    .ToList();
                foreach (var type in v3Enums)
                {
                    var descriptorType = typeof(EnumSchemaFilter<>).MakeGenericType(type);
                    options.SchemaFilterDescriptors.Add(new FilterDescriptor
                    {
                        Type = descriptorType,
                        Arguments = []
                    });
                }

                options.CustomSchemaIds(GetTypeName);
            });
        services.AddSwaggerGenNewtonsoftSupport();
        services.AddSignalR(o => { 
            o.EnableDetailedErrors = true;
            o.ClientTimeoutInterval = TimeSpan.FromSeconds(60); // default timeout is 30 seconds
        })
        .AddNewtonsoftJsonProtocol(o => o.PayloadSerializerSettings.ContractResolver = new DefaultContractResolver());

        // allow CORS calls from other both local and non-local hosts
        services.AddCors(options =>
        {
            options.AddDefaultPolicy(builder => { builder.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader(); });
        });

        // this caused issues with auth. https://stackoverflow.com/questions/43574552
        services.AddMvc(options =>
            {
                options.EnableEndpointRouting = false;
                options.AllowEmptyInputInBodyModelBinding = true;
                foreach (var formatter in options.InputFormatters)
                {
                    if (formatter.GetType() == typeof(NewtonsoftJsonInputFormatter))
                    {
                        ((NewtonsoftJsonInputFormatter)formatter).SupportedMediaTypes.Add(
                            MediaTypeHeaderValue.Parse("text/plain"));
                    }
                }

                options.Filters.Add(typeof(DatabaseBlockedFilter));
                options.Filters.Add(typeof(ServerNotRunningFilter));

                EmitEmptyEnumerableInsteadOfNullAttribute.MvcOptions = options;
            })
            .AddNewtonsoftJson(json =>
            {
                json.SerializerSettings.MaxDepth = 10;
                json.SerializerSettings.ContractResolver = new DefaultContractResolver
                {
                    NamingStrategy = new DefaultNamingStrategy()
                };
                json.SerializerSettings.NullValueHandling = NullValueHandling.Include;
                json.SerializerSettings.DefaultValueHandling = DefaultValueHandling.Populate;
                // json.SerializerSettings.DateFormatString = "yyyy-MM-dd";
            })
            .AddPluginControllers()
            .AddControllersAsServices();

        services.AddApiVersioning(o =>
        {
            o.ReportApiVersions = true;
            o.AssumeDefaultVersionWhenUnspecified = true;
            o.ApiVersionReader = ApiVersionReader.Combine(
                new QueryStringApiVersionReader(),
                new HeaderApiVersionReader("api-version"),
                new ShokoApiReader()
            );
        });
        services.AddVersionedApiExplorer(options =>
        {
            options.GroupNameFormat = "'v'VVV";
            options.SubstituteApiVersionInUrl = true;
        });
        services.AddResponseCaching();

        services.Configure<KestrelServerOptions>(options =>
        {
            options.AllowSynchronousIO = true;
        });
        return services;
    }

    private static string GetTypeName(Type type) =>
        GetTypeName(type.ToString()!.Replace("+", "."));

    private static string GetTypeName(string fullName)
    {
        if (!fullName.Contains('`'))
            return ConvertTypeName(fullName);

        var firstPart = fullName[..fullName.IndexOf('`')];
        var secondPart = fullName[(fullName.IndexOf('`') + 3)..^1];
        return ConvertTypeName(firstPart) + "_" + GetTypeName(secondPart) + "_";
    }

    private static string ConvertTypeName(string fullName)
    {
        string title;
        if (fullName.StartsWith("System.Collections.Generic."))
            title = fullName.Split('.').Skip(3).Join('.');
        else if (fullName.StartsWith("System.") || fullName.StartsWith("Microsoft."))
            title = fullName.Split('.').Skip(1).Join('.');

        // APIv0 (API independent plugin abstraction) schemas
        else if (fullName.StartsWith("Shoko.Plugin.Abstractions."))
            title = fullName
                .Replace("Shoko.Plugin.Abstractions.", "APIv0.Abstraction.")
                .Replace("TitleLanguage", "LanguageName")
                .Replace("DataModels.", "")
                .Replace("Enums.", "");

        // APIv0 (API independent plex webhook) schemas
        else if (fullName.StartsWith("Shoko.Models.Plex."))
            title = fullName.Replace("Shoko.Models.Plex.", "APIv0.Plex.");

        // APIv0 (API independent settings) schemas
        else if (fullName.StartsWith("Shoko.Server.Settings."))
            title = fullName
                .Replace("Shoko.Server.Settings.", "APIv0.Settings.");
        else if (fullName.StartsWith("Shoko.Models.FileQualityPreferences"))
            title = fullName
                .Replace("Shoko.Models.FileQualityPreferences", "APIv0.Settings.FileQualityPreferences");
        else if (fullName.StartsWith("Shoko.Models.Enums."))
            title = fullName
                .Replace("Shoko.Models.Enums.", "APIv0.Settings.");

        // APIv0 (API independent) schemas
        else if (fullName is "Shoko.Server.TagFilter.Filter")
            title = "APIv0.Shared.TagFilter";
        else if (fullName is "Shoko.Models.Enums.AnimeSeason")
            title = "APIv0.Shared.AnimeSeason";
        else if (fullName.StartsWith("Shoko.Server.Server."))
            title = fullName
                .Replace("Shoko.Server.Server.", "APIv0.Shared.")
                .Replace("Enums.", "");
        else if (fullName.StartsWith("Shoko.Common."))
            title = fullName
                .Replace("Shoko.Common.", "APIv0.Shared.")
                .Replace("Enums.", "");
        else if (fullName.StartsWith("Shoko.Server.Providers."))
            title = fullName
                .Replace("Shoko.Server.Providers.", "APIv0.")
                .Replace("AniDB", "Anidb")
                .Replace("TMDB", "Tmdb")
                .Replace("Anidb.Anidb", "Anidb.")
                .Replace("Tmdb.Tmdb", "Tmdb.");
        else if (fullName.StartsWith("Shoko.Server.API.v0.Controllers."))
            title = fullName
                .Replace("Shoko.Server.API.v0.Controllers.", "APIv0.")
                .Replace("Controller", "");
        else if (fullName.StartsWith("Shoko.Server.API.v0.Models."))
            title = fullName
                .Replace("Shoko.Server.API.v0.Models.", "APIv0.");

        // APIv3 schemas
        else if (fullName.StartsWith("Shoko.Server.API.v3.Controllers."))
            title = fullName
                .Replace("Shoko.Server.API.v3.Controllers.", "APIv3.")
                .Replace("Controller", "");
        else if (fullName.StartsWith("Shoko.Server.API.v3.Models."))
            title = fullName
                .Replace("Shoko.Server.API.v3.Models.", "APIv3.")
                .Replace("Common.", "")
                .Replace("Input.", "")
                .Replace("AniDB", "Anidb")
                .Replace("TMDB", "Tmdb")
                .Replace("Anidb.Anidb", "Anidb.")
                .Replace("Tmdb.Tmdb", "Tmdb.")
                .Replace("Image.Image", "Image");

        // All else exposed in APIv3 (mostly from the settings object), in addition to anything in APIv1 & APIv2.
        else
            title = string.Join(".", fullName.Replace("+", ".").Replace("`1", "").Split(".").TakeLast(2));

        return title;
    }

    private static OpenApiInfo CreateInfoForApiVersion(ApiVersionDescription description)
    {
        var info = new OpenApiInfo
        {
            Title = $"Shoko API {description.ApiVersion}",
            Version = description.ApiVersion.ToString(),
            Description = "Shoko Server API."
        };

        if (description.IsDeprecated)
        {
            info.Description += " This API version has been deprecated.";
        }

        return info;
    }

    public static IApplicationBuilder UseAPI(this IApplicationBuilder app)
    {
        var settings = Utils.SettingsProvider.GetSettings();
        var webSettings = settings.Web;
        if (!settings.SentryOptOut)
        {
            app.Use(async (context, next) =>
            {
                try
                {
                    await next.Invoke(context);
                }
                catch (Exception e)
                {
                    try
                    {
                        SentrySdk.CaptureException(e);
                    }
                    catch
                    {
                        // ignore
                    }
                    throw;
                }
            });
        }


#if DEBUG
        app.UseDeveloperExceptionPage();
#else
        if (webSettings.AlwaysUseDeveloperExceptions)
            app.UseDeveloperExceptionPage();
#endif

        // Create web ui directory and add the boot-strapper.
        var webUIDir = new DirectoryInfo(ApplicationPaths.Instance.WebPath);
        var backupDir = new DirectoryInfo(Path.Combine(ApplicationPaths.Instance.ExecutableDirectoryPath, "webui"));
        if (!webUIDir.Exists)
        {
            if (backupDir.Exists)
                CopyFilesRecursively(backupDir, webUIDir);
            else
                webUIDir.Create();
        }
        else if (
            backupDir.Exists &&
            webSettings.AutoReplaceWebUIWithIncluded &&
            WebUIUpdateService.LoadIncludedWebUIVersionInfo() is { } includedVersion &&
            (
                WebUIUpdateService.LoadWebUIVersionInfo() is not { } currentVersion ||
                (
                    includedVersion.VersionAsVersion > currentVersion.VersionAsVersion &&
                    (
                        (includedVersion.Channel is not ReleaseChannel.Debug && currentVersion.Channel is not ReleaseChannel.Debug) ||
                        (includedVersion.Channel is ReleaseChannel.Debug && currentVersion.Channel is ReleaseChannel.Debug)
                    )
                )
            )
        )
        {
            CopyFilesRecursively(backupDir, webUIDir);
        }

        if (webSettings.EnableSwaggerUI)
        {
            app.UseSwagger(c =>
            {
                c.PreSerializeFilters.Add((swaggerDoc, _) =>
                {
                    var version = double.Parse(swaggerDoc.Info.Version);
                    swaggerDoc.Servers.Add(new() { Url = $"/api/v{version:0}/" });

                    var basepathInt = $"/api/v{version:0}/";
                    var basepathDecimal = $"/api/v{version:0.0}/";
                    var paths = new OpenApiPaths();
                    foreach (var path in swaggerDoc.Paths)
                    {
                        if (!path.Key.Contains(basepathInt) && !path.Key.Contains(basepathDecimal))
                        {
                            path.Value.Servers.Clear();
                            path.Value.Servers.Add(new() { Url = "/" });
                        }

                        paths.Add(path.Key.Replace(basepathInt, "/").Replace(basepathDecimal, "/"), path.Value);
                    }
                    swaggerDoc.Paths = paths;
                });
            });
            app.UseSwaggerUI(
                options =>
                {
                    options.RoutePrefix = webSettings.SwaggerUIPrefix;
                    // build a swagger endpoint for each discovered API version
                    var provider = app.ApplicationServices.GetRequiredService<IApiVersionDescriptionProvider>();
                    foreach (var description in provider.ApiVersionDescriptions.OrderByDescending(a => a.ApiVersion))
                    {
                        options.SwaggerEndpoint($"/swagger/{description.GroupName}/swagger.json",
                            description.GroupName.ToUpperInvariant());
                    }
                    options.EnablePersistAuthorization();
                });
        }

        if (webSettings.EnableWebUI)
        {
            app.UseStaticFiles(new StaticFileOptions
            {
                FileProvider = new WebUiFileProvider(app.ApplicationServices.GetRequiredService<WebUIUpdateService>(), webSettings.WebUIPublicPath, webUIDir.FullName),
                RequestPath = webSettings.WebUIPublicPath,
                ServeUnknownFileTypes = true,
                DefaultContentType = "text/html",
                OnPrepareResponse = ctx =>
                {
                    var requestPath = ctx.File.PhysicalPath;
                    // We set the cache headers only for index.html file because it doesn't have a different hash when changed
                    if (requestPath?.EndsWith("index.html", StringComparison.OrdinalIgnoreCase) ?? false)
                    {
                        ctx.Context.Response.Headers.Append("Cache-Control", "no-cache, no-store, must-revalidate");
                        ctx.Context.Response.Headers.Append("Expires", "0");
                    }
                }
            });
        }

        // Important for first run at least
        app.UseAuthentication();

        app.UseRouting();
        app.UseEndpoints(conf =>
        {
            conf.MapHub<LoggingHub>("/signalr/logging");
            conf.MapHub<AggregateHub>("/signalr/aggregate");
        });

        app.UseCors(options => options.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader());

        app.UseMvc();

        return app;
    }

    private static void CopyFilesRecursively(DirectoryInfo source, DirectoryInfo target)
    {
        if (target.Exists)
            target.Delete(recursive: true);

        target.Create();
        foreach (var dir in source.GetDirectories())
        {
            CopyFilesRecursively(dir, target.CreateSubdirectory(dir.Name));
        }

        foreach (var file in source.GetFiles())
        {
            file.CopyTo(Path.Combine(target.FullName, file.Name));
        }
    }
}
